### JPA

Java Persistance API

자바 진영에서 ORM(Object-Relational Mapping) 기술 표준으로 사용되는 인터페이스의 모음.
실제적으로 구현된 것이 아니라 구현된 클래스와 매핑을 해주기 위해 사용되는 프레임워크.
대표적인 오픈소스로는 Hibernate가 있다.

(참고:https://dbjh.tistory.com/77)

### ORM
Object-Relational Mapping

애플리케이션 Class와 RDB(Relational DataBase)의 테이블을 매핑한다는 뜻.
어플리케이션의 객체를 RDB 테이블에 자동으로 영속화 해주는 것

### 장점
* SQL문이 아닌 Method를 통해 DB를 조작할 수 있어, 개발자는 객체 모델을 이용하여 비즈니스 로직을 구성하는데만 집중할 수 있음
* Query와 같이 필요한 선언문, 할당 등의 부수적인 코드가 줄어들어, 각종 객체에 대한 코드를 별도로 작성하여 코드의 가독성을 높임
* 객체지향적인 코드 작성이 가능하다. 오직 객체지향적 접근만 고려하면 되기 때문에 생산성 증가
* 매핑하는 정보가 Class로 명시되어 있기 때문에 ERD를 보는 의존도를 낮출 수 있고 유지보수 및 리팩토링에 유리
* MySQL을 사용하다가 PostgreSQL로 변환한다고해도 쿼리를 수정할 필요가 없음

### 단점
* 프로젝트의 규모가 크고 복잡하여 설계가 잘못된 경우, 속도 저하 및 일관성을 무너뜨리는 문제점이 생길 수 있음
* 복잡하고 무거운 Query는 속도를 위해 별도의 튜닝이 필요하기 때문에 결국 SQL문을 써야할 수도 있음
* 학습비용이 비쌈

### 왜 JPA를 사용해야 하는가?

#### 생산성
* 자바 컬렉션에 객체를 저장하듯 JPA에게 저장할 객체를 전달
* INSERT SQL을 작성하고 JDBC API 사용하는 지루하고 반복적인 일을 JPA가 대신 처리해준다.
* CREATE TABLE같은 DDL문 자동 생성
* 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 *역전*

```java
jpa.persist(member); //저장
Member member = jpa.find(memberId); //조회
```

#### 유지보수
* 엔티티에 필드 추가시 등록, 수정, 조회 관련 코드 모두 변경
JPA를 사용하면 이런 과정을 JPA가 대신 처리
개발자가 작성해야 할 SQL과 JDBC API 코드를 JPA가 대신 처리해 주어서 유지보수해야 하는 코드의 수가 줄어듦

#### 패러다임 불일치 해결
* 상속, 연관 관계, 객체 그래프 탐색, 비교하기 같은 패러다임 불일치 해결

#### 성능
* 다양한 성능 최적화 기회 제공
* 어플리케이션과 데이터 베이스 사이에 존재함으로 여러 최적화 시도 가능

#### 데이터 접근 추상화와 벤더 독립성
* 데이터베이스 기술에 종속되지 않도록 한다.
* 데이터베이스를 변경하면 JPA에게 다른 데이터베이스를 사용한다고 알려주면 됨

(참고:https://ultrakain.gitbooks.io/jpa/content/chapter1/chapter1.3.html)